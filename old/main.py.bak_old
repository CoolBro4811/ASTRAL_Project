# Implementation of a "math-first" star detection pipeline.
# This code is intended to be self-contained and minimal-dependency.
# It uses numpy and matplotlib (matplotlib for a quick visual check).
# It will try to use scipy for optional Gaussian fitting but has a fallback.
#
# The pipeline implements:
# 1) background estimation via blockwise median (pure numpy)
# 2) background subtraction and MAD-based noise estimation
# 3) matched filtering with a Gaussian kernel (convolution via FFT)
# 4) thresholding (k * sigma)
# 5) connected components (pure numpy BFS)
# 6) centroid & flux estimation (moments)
# 7) optional 2D Gaussian fit per detection (uses scipy if available)
#
# At the end it demonstrates the pipeline on a synthetic image.
#
# You can copy these functions into your project. If you want, I can
# strip the demo part and return just the library functions.
#
# Run-time note: this is designed for clarity, not extreme speed.

import matplotlib.pyplot as plt
import numpy as np
from astropy.io import fits

# Try to import scipy.optimize.curve_fit for optional fitting
try:
    from scipy.optimize import curve_fit

    SCIPY_AVAILABLE = True
except Exception:
    SCIPY_AVAILABLE = False

from numpy.fft import fft2, fftshift, ifft2


def make_gaussian_kernel(size, sigma):
    """Return a square Gaussian kernel of shape (size,size) with given sigma.
    size should be odd for symmetry.
    """
    assert size % 2 == 1, "size should be odd"
    r = size // 2
    y, x = np.mgrid[-r : r + 1, -r : r + 1]
    g = np.exp(-(x**2 + y**2) / (2 * sigma**2))
    g /= g.sum()
    return g


def fft_convolve(image, kernel):
    """Convolve image with kernel using FFT (handles arbitrary sizes)."""
    # pad to sum of sizes -1
    s1 = np.array(image.shape)
    s2 = np.array(kernel.shape)
    shape = s1 + s2 - 1
    # next power of two could be faster, but we keep simple
    fimage = fft2(image, shape)
    fkernel = fft2(kernel, shape)
    conv = np.real(ifft2(fimage * fkernel))
    # crop to original image shape (centered)
    start = (s2 - 1) // 2
    end = start + s1
    ys = slice(start[0], end[0])
    xs = slice(start[1], end[1])
    return conv[ys, xs]


def blockwise_median_background(image, block_size=64):
    """Estimate background by computing median in non-overlapping blocks,
    then upsampling with simple bilinear interpolation (via numpy.repeat and smoothing).
    block_size: size of blocks (square) to compute medians.
    """
    H, W = image.shape
    bh = int(np.ceil(H / block_size))
    bw = int(np.ceil(W / block_size))
    # pad image to multiple of block_size
    pad_h = bh * block_size - H
    pad_w = bw * block_size - W
    img_pad = np.pad(image, ((0, pad_h), (0, pad_w)), mode="reflect")
    med = np.zeros((bh, bw))
    for i in range(bh):
        for j in range(bw):
            block = img_pad[
                i * block_size : (i + 1) * block_size,
                j * block_size : (j + 1) * block_size,
            ]
            med[i, j] = np.median(block)
    # upsample med to padded size using repeat then smooth a bit
    up = np.repeat(np.repeat(med, block_size, axis=0), block_size, axis=1)
    up = up[: img_pad.shape[0], : img_pad.shape[1]]
    # smooth by a small gaussian to avoid blockiness
    small_k = make_gaussian_kernel(9, sigma=1.5)
    up_smooth = fft_convolve(up, small_k)
    # crop to original
    bg = up_smooth[:H, :W]
    return bg


def mad_std(data):
    """Estimate standard deviation using median absolute deviation (MAD)."""
    med = np.median(data)
    mad = np.median(np.abs(data - med))
    # for Gaussian distributed noise, sigma â‰ˆ 1.4826 * MAD
    return 1.4826 * mad


def label_connected_components(mask):
    """Label connected components (8-connectivity) in a boolean mask.
    Returns list of component pixel coordinates arrays: [(ys, xs), ...]
    """
    H, W = mask.shape
    visited = np.zeros_like(mask, dtype=bool)
    components = []
    # offsets for 8-connectivity
    neigh = [
        (-1, -1),
        (-1, 0),
        (-1, 1),
        (0, -1),
        (0, 1),
        (1, -1),
        (1, 0),
        (1, 1),
    ]
    for i in range(H):
        for j in range(W):
            if mask[i, j] and not visited[i, j]:
                # BFS/stack
                stack = [(i, j)]
                ys = []
                xs = []
                visited[i, j] = True
                while stack:
                    y, x = stack.pop()
                    ys.append(y)
                    xs.append(x)
                    for dy, dx in neigh:
                        ny, nx = y + dy, x + dx
                        if (
                            0 <= ny < H
                            and 0 <= nx < W
                            and mask[ny, nx]
                            and not visited[ny, nx]
                        ):
                            visited[ny, nx] = True
                            stack.append((ny, nx))
                components.append(
                    (np.array(ys, dtype=int), np.array(xs, dtype=int))
                )
    return components


def compute_centroid_and_flux(image, ys, xs, subtract_local_bg=False):
    """Compute centroid (x,y) and flux for given pixel coordinates (arrays ys, xs).
    If subtract_local_bg is True, estimate local background as median of a surrounding annulus.
    Returns (x_centroid, y_centroid, flux, peak_value).
    """
    vals = image[ys, xs].astype(float)
    if subtract_local_bg:
        # compute a local background using a bounding box expanded by 3 pixels
        y0, y1 = max(0, ys.min() - 3), min(image.shape[0], ys.max() + 4)
        x0, x1 = max(0, xs.min() - 3), min(image.shape[1], xs.max() + 4)
        local = image[y0:y1, x0:x1]
        # mask is current pixels
        mask_local = np.ones_like(local, dtype=bool)
        rel_ys = ys - y0
        rel_xs = xs - x0
        mask_local[rel_ys, rel_xs] = False
        if np.any(mask_local):
            bg = np.median(local[mask_local])
        else:
            bg = np.median(local)
        vals = vals - bg
    total = vals.sum()
    if total <= 0:
        # fallback: return simple peak
        peak_idx = np.argmax(vals)
        return (
            float(xs[peak_idx]),
            float(ys[peak_idx]),
            float(total),
            float(vals.max()),
        )
    x_c = np.sum(xs * vals) / total
    y_c = np.sum(ys * vals) / total
    peak = vals.max()
    return x_c, y_c, total, peak


def twoD_gaussian(coords, amp, x0, y0, sigma_x, sigma_y, theta, offset):
    """2D Gaussian used for curve fitting. coords is (y.flatten(), x.flatten())."""
    y, x = coords
    x0 = float(x0)
    y0 = float(y0)
    a = (np.cos(theta) ** 2) / (2 * sigma_x**2) + (np.sin(theta) ** 2) / (
        2 * sigma_y**2
    )
    b = -(np.sin(2 * theta)) / (4 * sigma_x**2) + (np.sin(2 * theta)) / (
        4 * sigma_y**2
    )
    c = (np.sin(theta) ** 2) / (2 * sigma_x**2) + (np.cos(theta) ** 2) / (
        2 * sigma_y**2
    )
    return offset + amp * np.exp(
        -(a * (x - x0) ** 2 + 2 * b * (x - x0) * (y - y0) + c * (y - y0) ** 2)
    )


def fit_gaussian_around(image, yc, xc, radius=6):
    """Fit a 2D Gaussian around the approximate centroid (yc, xc) with window radius (pixels).
    Returns fit parameters dict or None if fit fails.
    Requires scipy.optimize.curve_fit. If not available, returns None.
    """
    if not SCIPY_AVAILABLE:
        return None
    H, W = image.shape
    y0 = int(np.clip(np.round(yc) - radius, 0, H - 1))
    y1 = int(np.clip(np.round(yc) + radius + 1, 0, H))
    x0 = int(np.clip(np.round(xc) - radius, 0, W - 1))
    x1 = int(np.clip(np.round(xc) + radius + 1, 0, W))
    sub = image[y0:y1, x0:x1].astype(float)
    ys, xs = np.mgrid[0 : sub.shape[0], 0 : sub.shape[1]]
    coords = (ys.ravel(), xs.ravel())
    # initial guesses from moments
    amp0 = sub.max() - np.median(sub)
    x0_init = (xs * sub).sum() / sub.sum()
    y0_init = (ys * sub).sum() / sub.sum()
    sigma_init = 1.5
    p0 = [amp0, x0_init, y0_init, sigma_init, sigma_init, 0.0, np.median(sub)]
    try:
        popt, pcov = curve_fit(
            lambda flattened_coords, amp, x0i, y0i, sx, sy, th, off: twoD_gaussian(
                (coords[0], coords[1]), amp, x0i, y0i, sx, sy, th, off
            ),
            np.concatenate([coords[0], coords[1]]),
            sub.ravel(),
            p0=p0,
            maxfev=20000,
        )
        amp, x0f, y0f, sx, sy, th, off = popt
        # translate x0f,y0f back to full image coordinates
        x0f_full = x0 + x0f
        y0f_full = y0 + y0f
        return {
            "amp": amp,
            "x": x0f_full,
            "y": y0f_full,
            "sx": sx,
            "sy": sy,
            "theta": th,
            "offset": off,
        }
    except Exception as e:
        # fit failed
        return None


def detect_stars(
    image,
    k=5.0,
    psf_sigma=1.5,
    bg_block=64,
    matched_filter=True,
    min_area=3,
    fit_gaussian=True,
):
    """Full detection pipeline:
    - estimate background
    - subtract background
    - estimate noise with MAD on background-subtracted image
    - optionally matched filter (convolve with gaussian of psf_sigma)
    - threshold image at median + k*sigma
    - label components and compute centroid/flux
    - optionally fit gaussian to each detection (if scipy present)
    Returns list of detections (dicts).
    """
    img = np.array(image, dtype=float)
    # background
    bg = blockwise_median_background(img, block_size=bg_block)
    img_sub = img - bg
    med = np.median(img_sub)
    sigma = mad_std(img_sub)
    # matched filter: convolve with gaussian kernel of size ~ 6*sigma
    if matched_filter and psf_sigma is not None:
        ksize = int(max(3, int(8 * psf_sigma) // 2 * 2 + 1))  # make odd
        gk = make_gaussian_kernel(ksize, psf_sigma)
        img_filt = fft_convolve(img_sub, gk)
    else:
        img_filt = img_sub.copy()
    thr = med + k * sigma
    mask = img_filt > thr
    # remove tiny islands via area thresholding after labeling
    comps = label_connected_components(mask)
    detections = []
    for ys, xs in comps:
        if ys.size < min_area:
            continue
        x_c, y_c, flux, peak = compute_centroid_and_flux(
            img_sub, ys, xs, subtract_local_bg=True
        )
        det = {
            "x": x_c,
            "y": y_c,
            "flux": flux,
            "peak": peak,
            "area": int(ys.size),
        }
        if fit_gaussian and SCIPY_AVAILABLE:
            fit = fit_gaussian_around(img, y_c, x_c, radius=6)
            if fit is not None:
                det.update({"fit": fit})
        detections.append(det)
    # sort by peak brightness descending
    detections.sort(key=lambda d: d["peak"], reverse=True)
    return detections, {
        "background": bg,
        "img_sub": img_sub,
        "img_filt": img_filt,
        "threshold": thr,
    }


def load_fits_image(filename, ext=0):
    """
    Load a FITS image and return it as a 2D numpy array (float).
    - filename: path to FITS file
    - ext: HDU extension index (default 0 = primary)
    """
    with fits.open(filename) as hdul:
        data = hdul[ext].data.astype(float)
    # If the image is multi-dimensional (e.g. color planes), take the first 2D slice
    if data.ndim > 2:
        data = data[0]
    return data


image = load_fits_image("../fits/d143.fits")
detections, aux = detect_stars(image, k=5.0, psf_sigma=1.5)


print(f"Detected {len(detections)} candidate stars (sorted by peak):\n")
for i, d in enumerate(detections[:20], 1):
    s = f"{i:2d}: x={d['x']:.2f}, y={d['y']:.2f}, flux={d['flux']:.1f}, peak={d['peak']:.1f}, area={d['area']}"
    if "fit" in d and d["fit"] is not None:
        s += f", fit_amp={d['fit']['amp']:.1f}, fit_x={d['fit']['x']:.2f}, fit_y={d['fit']['y']:.2f}"
    print(s)

# Visualize results
fig, axs = plt.subplots(1, 3, figsize=(14, 5))
axs[0].imshow(image, origin="lower", cmap="gray", interpolation="nearest")
axs[0].set_title("Synthetic image")
im1 = axs[1].imshow(
    aux["img_sub"], origin="lower", cmap="gray", interpolation="nearest"
)
axs[1].set_title("Background-subtracted")
im2 = axs[2].imshow(
    aux["img_filt"], origin="lower", cmap="gray", interpolation="nearest"
)
axs[2].set_title("Matched-filtered")
for ax in axs:
    ax.set_xticks([])
    ax.set_yticks([])

# mark detections on image
for d in detections:
    axs[0].plot(d["x"], d["y"], marker="+", markersize=8, markeredgewidth=1.2)
plt.tight_layout()
plt.show()

# Show a tiny table of detections
import pandas as pd

tbl = []
for d in detections:
    row = {
        "x": d["x"],
        "y": d["y"],
        "flux": d["flux"],
        "peak": d["peak"],
        "area": d["area"],
    }
    if "fit" in d and d["fit"] is not None:
        row.update(
            {
                "fit_amp": d["fit"]["amp"],
                "fit_x": d["fit"]["x"],
                "fit_y": d["fit"]["y"],
                "fit_sx": d["fit"]["sx"],
            }
        )
    tbl.append(row)
df = pd.DataFrame(tbl)
# display as table to user
import caas_jupyter_tools as tools

tools.display_dataframe_to_user("Detected stars", df.head(200))
